# name: Deploy to Free Tier EC2 (K3s)

# on:
#   push:
#     branches: [ "main" ]

# env:
#   AWS_REGION: us-east-1
#   # Just the name, not the full URL. The pipeline will figure out the URL.
#   REPO_NAME: my-html-app-repo 
#   CONTAINER_NAME: web-server
#   DEPLOYMENT_NAME: my-static-site

# jobs:
#   deploy:
#     name: Build & Deploy
#     runs-on: ubuntu-latest

#     steps:
#     - name: Checkout Code
#       uses: actions/checkout@v3

#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v1
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#         aws-region: ${{ env.AWS_REGION }}

#     # 1. Login to AWS ECR Public
#     - name: Login to Amazon ECR Public
#       id: login-ecr-public
#       uses: aws-actions/amazon-ecr-login@v1
#       with:
#         registry-type: public

#     # 2. AUTO-CREATE REPO if it doesn't exist
#     - name: Ensure ECR Repository Exists
#       run: |
#         aws ecr-public describe-repositories --repository-names ${{ env.REPO_NAME }} --region ${{ env.AWS_REGION }} || \
#         aws ecr-public create-repository --repository-name ${{ env.REPO_NAME }} --region ${{ env.AWS_REGION }}

#     # 3. Build and Push (Using dynamic registry URL)
#     - name: Build, tag, and push image
#       id: build-image
#       env:
#         ECR_REGISTRY: ${{ steps.login-ecr-public.outputs.registry }}
#         IMAGE_TAG: ${{ github.sha }}
#       run: |
#         # Build the full image URL dynamically
#         IMAGE_URI="$ECR_REGISTRY/${{ env.REPO_NAME }}:$IMAGE_TAG"
        
#         docker build -t $IMAGE_URI .
#         docker push $IMAGE_URI
        
#         # Save the image URI for the next step
#         echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

#     # 4. Deploy to EC2 via SSH
#     - name: Deploy to EC2 (K3s)
#       uses: appleboy/ssh-action@master
#       with:
#         host: ${{ secrets.EC2_HOST }}
#         username: ubuntu
#         key: ${{ secrets.EC2_SSH_KEY }}
#         # Pass the dynamic Image URI we just built
#         envs: CONTAINER_NAME,DEPLOYMENT_NAME
#         script: |
#           # Define the specific image URL inside the script
#           IMAGE_URI="${{ steps.build-image.outputs.image_uri }}"
          
#           # Create the deployment file
#           cat <<EOF > deployment.yaml
#           apiVersion: apps/v1
#           kind: Deployment
#           metadata:
#             name: $DEPLOYMENT_NAME
#           spec:
#             replicas: 1
#             selector:
#               matchLabels:
#                 app: $DEPLOYMENT_NAME
#             template:
#               metadata:
#                 labels:
#                   app: $DEPLOYMENT_NAME
#               spec:
#                 containers:
#                 - name: $CONTAINER_NAME
#                   image: $IMAGE_URI
#                   ports:
#                   - containerPort: 80
#                   resources:
#                     requests:
#                       memory: "64Mi"
#                       cpu: "50m"
#                     limits:
#                       memory: "128Mi"
#                       cpu: "100m"
#           ---
#           apiVersion: v1
#           kind: Service
#           metadata:
#             name: my-service
#           spec:
#             type: ClusterIP
#             selector:
#               app: $DEPLOYMENT_NAME
#             ports:
#             - protocol: TCP
#               port: 80
#               targetPort: 80
#           EOF
          
#           # Apply and Restart
#           sudo k3s kubectl apply -f deployment.yaml
#           sudo k3s kubectl rollout restart deployment/$DEPLOYMENT_NAME